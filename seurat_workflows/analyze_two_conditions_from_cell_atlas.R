# Title: Script to analyze two conditations from a 'cell atlas'. Data is subsetted from the cell atlas RData based on the specified conditions.
# Author: Pascal N. Timshel, Pers Lab
# Date: December 2017

### Method
# 1a) load Seurat object from pre-computed RData file (generated by generate_cell_atlas.R and *cell_atlas notebook*)
# 2b) you get the cell type annotations from cell_atlas notebook
# 3) Subset Seurat object based on conditions
# 4) Run analysis (within cluster DE, ...)



######################################################################
############################## USAGE #################################
######################################################################

# time Rscript analyze_two_conditions_from_cell_atlas.R --analysis_conditions lira_vs_pf |& tee analyze_two_conditions_from_cell_atlas.lira_vs_pf.out.txt
# time Rscript analyze_two_conditions_from_cell_atlas.R --analysis_conditions hfd_vs_chow |& tee analyze_two_conditions_from_cell_atlas.hfd_vs_chow.out.txt
# time Rscript analyze_two_conditions_from_cell_atlas.R --analysis_conditions hfd_vs_pf |& tee analyze_two_conditions_from_cell_atlas.hfd_vs_pf.out.txt

# time Rscript analyze_two_conditions_from_cell_atlas.R --analysis_conditions lira_vs_pf --output_prefix testX --test_run

######################################################################
########################### OptParse ################################
######################################################################
library(optparse)

# specify our desired options in a list
# by default OptionParser will add an help option equivalent to 
# make_option(c("-h", "--help"), action="store_true", default=FALSE, 
#               help="Show this help message and exit")

option_list <- list( 
  make_option("--analysis_conditions", type="character",
              help = "Choose from 'lira_vs_pf', 'hfd_vs_chow', 'hfd_vs_pf'"),
  make_option("--output_prefix", type="character", default=NULL,
              help = "Prefix for output files"),
  make_option("--test_run", action="store_true", default=FALSE, 
              help="Run in 'test mode': load only 500 cells and a limited number of highly expressed genes."),
  make_option("--n_cores", type="integer", default=10,
              help = "Number of cores to use for parallelization [default %default]")
  
)

# get command line options, if help option encountered print help and exit,
# otherwise if options not found on command line then set defaults, 
opt <- parse_args(OptionParser(option_list=option_list))


analysis_conditions <- opt$analysis_conditions # get argument


if (is.null(opt$output_prefix)) { # if no argument given, we set the output prefix to analysis_conditions
  output_prefix <- analysis_conditions
  print(sprintf("No output_prefix given. Using output_prefix = %s", output_prefix))
} else {
  output_prefix <- opt$output_prefix
  print(sprintf("Got output_prefix %s", output_prefix))
}


FLAG_TEST_RUN <- opt$test_run # set to TRUE to load only 500 cells and a limited number of highly expressed genes
# ^ uses Seurat.CreateObj.test_small_dataset()

N_CORES <- opt$n_cores


# IMPORTANT: condition1 and condition2 names *MUST* match the folder names in /data/sc-10x/data-runs/170612-perslab-arc_lira/
if (analysis_conditions == "lira_vs_pf") {
  condition1 <-"hfd_ad_lib_lira"
  condition2 <-"hfd_pair_fed"
} else if (analysis_conditions == "hfd_vs_chow") {
  condition1 <-"hfd_ad_lib"
  condition2 <-"chow"
} else if (analysis_conditions == "hfd_vs_pf") {
  condition1 <-"hfd_ad_lib"
  condition2 <-"hfd_pair_fed"
} else {
  stop("Wrong argument for analysis_conditions")
}

print(sprintf("========== RUNNING analysis_conditions = %s ==========", analysis_conditions))

######################################################################
########################### CONSTANTS ################################
######################################################################


res.primary <- 0.8 # the primary resolution - will be used for cluster marker identification.

N_DIMS <- 20 # dims.use for CCA (and tSNE)
N_MIN_CELLS_PER_TREATMENT_FOR_DE_ANALYSIS <- 10 # used for condition_de_genes(seurat_obj)


file.RData.cell_atlas <- "/projects/timshel/sc-arc_lira/src/out-generate_cell_atlas/arc_lira_cell_atlas-core_objs.RData" # seurat_obj, df.cluster_markers
# file.RData.cell_atlas <- "/projects/timshel/sc-arc_lira/src/nb-cell_atlas-v2/arc_lira_cell_atlas-core_objs.annotated.RData" # seurat_obj, df.cluster_markers

######################################################################
######################### DENPENDENCIES ##############################
######################################################################

library(Seurat)
library(tidyverse)

library(parallel)

# tibble (part of tidyverse)
# plyr (plyr::join_all)


######################################################################
########################### FUNCTIONS ################################
######################################################################


condition_de_genes <- function(seurat_obj) {
  # Find differentially eseurat_objpressed genes between the two conditions
  # *OBS* note that this function will return NULL if the 'if statement' is not true.
  
  statistical_tests <- c("wilcox", "negbinom")
  
  flag_condition1_ok <- sum(seurat_obj@meta.data$condition == condition1) > N_MIN_CELLS_PER_TREATMENT_FOR_DE_ANALYSIS
  flag_condition2_ok <- sum(seurat_obj@meta.data$condition == condition2) > N_MIN_CELLS_PER_TREATMENT_FOR_DE_ANALYSIS
  if (!(flag_condition1_ok & flag_condition2_ok)) { # if one of the flags are FALSE, the function will return NULL
    return(NULL)
  }
  
  
  list.findmarkers <- list()
  for (test.use in statistical_tests) {
    print(sprintf("Running FindMarkers for statistical test %s", test.use))
    df.res <- FindMarkers(seurat_obj, ident.1=condition1, ident.2=condition2, test.use=test.use) # Returns data frame
    # OBS: SetAllIdent(seurat_obj, "condition") MUST have been called on the Seurat object prior to this, or you will get an error "Identity : hfd_ad_lib_lira not found."
    
    ### FindMarkers() OUT SNIPPET [data frame]. NOTE THAT GENE NAMERS ARE ROWNAMES AND NOT A COLUMN.
    # p_val avg_logFC pct.1 pct.2    p_val_adj
    # GNG11     8.794299e-19  6.014094   1.0 0.000 2.022689e-16
    # CLU       8.794299e-19  5.869606   1.0 0.000 2.022689e-16
    list.findmarkers[[test.use]] <- df.res %>% 
      rename_all(funs(paste0(names(df.res), ".", test.use))) %>% 
      rownames_to_column(var="gene") # add suffix to all columns and add gene as column
  }
  df.de_analysis <- plyr::join_all(list.findmarkers, type="full", by="gene") # plyr join list of data frame.
  
  df.de_analysis <- df.de_analysis %>% 
    rename( UQ(rlang::sym("logFC")) := UQ(rlang::sym(sprintf("avg_logFC.%s",statistical_tests[1]))) ) %>%  # renaming one of the avg_logFC columns. They are all the same, since they are not dependent on the statistical test.
    rename( UQ(rlang::sym("pct1")) := UQ(rlang::sym(sprintf("pct.1.%s",statistical_tests[1]))) ) %>% # renaming one pct.1 columns
    rename( UQ(rlang::sym("pct2")) := UQ(rlang::sym(sprintf("pct.2.%s",statistical_tests[1]))) ) %>% # renaming one pct.2 columns
    select(-starts_with("pct."), -starts_with("avg_logFC")) %>% # remove redundant columns
    rename( avg_logFC = logFC ) %>%  # renaming BACK AGAIN
    rename( UQ(rlang::sym("pct.1")) := pct1 ) %>%  # renaming BACK AGAIN, not sure if UQ(rlang::sym()) is needed
    rename( UQ(rlang::sym("pct.2")) := pct2 ) %>%  # renaming BACK AGAIN, not sure if UQ(rlang::sym()) is needed
    mutate(
      p_val = UQ(rlang::sym(sprintf("p_val.%s", tail(statistical_tests, n=1)))),
      p_val_adj = UQ(rlang::sym(sprintf("p_val_adj.%s", tail(statistical_tests, n=1))))
    ) %>%
    arrange( UQ(rlang::sym(sprintf("p_val.%s", tail(statistical_tests, n=1)))) ) # sort by p_val for the last run of statistical_tests
  
  ### SNITPPIT df.de_analysis
  # gene p_val.wilcox      logFC  pct1  pct2 p_val_adj.wilcox p_val.negbinom p_val_adj.negbinom
  # 1 FP671120.3 1.381887e-32 -1.2566769 0.979 1.000     4.588694e-28              0                  0
  # 2 FP236383.2 1.381887e-32 -1.2567393 0.979 1.000     4.588694e-28              0                  0
  # 3   FP236383 1.381887e-32 -1.2568003 0.979 1.000     4.588694e-28              0                  0
  return(df.de_analysis)
}


###########################################################################
############################# READ DATA ###################################
###########################################################################
print("Reading data")

load(file.RData.cell_atlas) # seurat_obj, df.cluster_markers


seurat_obj@meta.data$condition <- seurat_obj@meta.data$group_name # *OBS*: set the condition variable

##############################################################################
############################# PROCESS DATA ###################################
##############################################################################
print("Processing data")

if (FLAG_TEST_RUN) {
  print("***RUNNING TEST DATA MODE***")
  seurat_obj <- SubsetData(SetAllIdent(seurat_obj, id=paste0("res.",res.primary)), max.cells.per.ident=50, random.seed=1)
  print(seurat_obj)
} else {
  print("***RUNNING FULL DATA MODE***")
  print(seurat_obj)
}

##############################################################################
###################### SUBSET DATA BY CONDITIONS #############################
##############################################################################
print("Subsetting data...")

seurat_obj.sub_conditions <- SubsetData(SetAllIdent(seurat_obj, id="condition"), ident.use=c(condition1, condition2)) # subsetting based on conditions

seurat_obj.sub_conditions <- SetAllIdent(seurat_obj.sub_conditions, id=paste0("res.", res.primary)) # # set ident to the primary ident

##########################################################################
########################### CLUSTER IDs #################################
##########################################################################
cluster_ids <- sort(unique(as.numeric(seurat_obj.sub_conditions@meta.data[,paste0("res.",res.primary)]))) # numeric vector, 0, 1, 2, 3, ... (N_CLUSTERS-1)


##########################################################################
################## Condition all cells (GLOBAL) DE genes #################
##########################################################################
print("Condition DE genes GLOBAL")

# Identify DE genes across all clusters
df.condition_de_genes_all_cells <- FindMarkers(SetAllIdent(seurat_obj.sub_conditions, id="condition"), ident.1=condition1, ident.2=condition2, test.use = "negbinom") # Returns data frame

##########################################################################
################## Subset Seurat object into clusters ####################
##########################################################################

# Subset seurat object into clusters
list_of_seurat_objs_per_cluster <- lapply(cluster_ids, function(x) SubsetData(seurat_obj.sub_conditions, ident.use=x)) # create a list of seurat objects that each contains only cells from a single cluster.
names(list_of_seurat_objs_per_cluster) <- cluster_ids # **IMPORTANT** if list is not named, the cluster information COULD BE lost in condition_de_genes() because it may return null.
list_of_seurat_objs_per_cluster <- lapply(list_of_seurat_objs_per_cluster, function(x) SetAllIdent(x, "condition")) # set 'ident' to our condition variable.


##########################################################################
################## Condition within cluster DE genes  ###################
##########################################################################
print("Condition DE genes within cluster")

# # Identify DE genes within clusters | NON-PARALLEL
# list_of_dfs.condition_de_genes_per_cluster <- lapply(list_of_seurat_objs_per_cluster, condition_de_genes) # returns a named list of data frames. Names are the names from the input list.
# df.condition_de_genes_per_cluster <- bind_rows(list_of_dfs.condition_de_genes_per_cluster, .id="cluster")
# df.condition_de_genes_per_cluster$cluster <- as.numeric(df.condition_de_genes_per_cluster$cluster) - 1 # CORRECTING FOR OFF-SET (Seurat cluster IDs are zero-based. ONLY RUN THIS LINE ONCE

# Identify DE genes within clusters
cl <- makeCluster(N_CORES, type = "FORK")
clusterEvalQ(cl, library(Seurat))
clusterEvalQ(cl, library(tidyverse))
clusterEvalQ(cl, library(rlang)) # needed for using UQ()
list_of_dfs.condition_de_genes_per_cluster <-parLapply(cl, list_of_seurat_objs_per_cluster, condition_de_genes) # PARALLEL VERSION. returns a list of data frames (not named - only 'indexes')
stopCluster(cl)
names(list_of_dfs.condition_de_genes_per_cluster) <- cluster_ids # NOT IMPORANT (although lapply will have wrong 'offset' for cluster, i.e. 1, 2, 3 instead of 0, 1, 2, ..): adding names before calling bind_rows. In this way we ensure that the cluster information is kept. this works even if condition_de_genes returns one or more "NULL" values.
df.condition_de_genes_per_cluster <- bind_rows(list_of_dfs.condition_de_genes_per_cluster, .id="cluster") # returns results for all genes (no p_val_adj filter)


file.out.tmp <- sprintf("%s-condition_de_genes_per_cluster-res_%s.csv", output_prefix, res.primary)
write.csv(df.condition_de_genes_per_cluster, file=file.out.tmp ,row.names=F, quote=F)

##########################################################################
########### SAVE FINAL SESSION VARIABLES AND SEURAT OBJECTS  #############
##########################################################################

# print("Saving session...")
# save.image(file=sprintf("%s-rsession_complete.RData", output_prefix)) # save image

print("Saving Seurat object...")
save(seurat_obj.sub_conditions, df.condition_de_genes_all_cells, df.condition_de_genes_per_cluster, file=sprintf("%s-core_objs.RData", output_prefix))



print("Script DONE!")
